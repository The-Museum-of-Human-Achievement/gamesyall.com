#!/bin/bash
# Script to deploy to production server (Optimized with content-hash comparison)
# Only uploads files that have actually changed, not just regenerated by Jekyll

set -e

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Get the project root (two levels up from deploy/scripts/)
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Manifest storage location (persists between deploys)
MANIFEST_DIR="$PROJECT_ROOT/deploy/.manifests"
LOCAL_MANIFEST="$MANIFEST_DIR/local_manifest.txt"
REMOTE_MANIFEST="$MANIFEST_DIR/remote_manifest.txt"
UPLOAD_LIST="$MANIFEST_DIR/upload_list.txt"
DELETE_LIST="$MANIFEST_DIR/delete_list.txt"

# Load environment variables from deploy folder
if [ -f "$PROJECT_ROOT/deploy/.env" ]; then
    source "$PROJECT_ROOT/deploy/.env"

    # Strip quotes from variables if present using bash parameter expansion
    PRODUCTION_HOST="${PRODUCTION_HOST%\"}"
    PRODUCTION_HOST="${PRODUCTION_HOST#\"}"
    PRODUCTION_USERNAME="${PRODUCTION_USERNAME%\"}"
    PRODUCTION_USERNAME="${PRODUCTION_USERNAME#\"}"
    PRODUCTION_PASSWORD="${PRODUCTION_PASSWORD%\"}"
    PRODUCTION_PASSWORD="${PRODUCTION_PASSWORD#\"}"
    PRODUCTION_PATH="${PRODUCTION_PATH%\"}"
    PRODUCTION_PATH="${PRODUCTION_PATH#\"}"
else
    echo "ERROR: .env file not found at $PROJECT_ROOT/deploy/.env"
    exit 1
fi

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Parse command line arguments
FORCE_FULL_DEPLOY=false
SKIP_BUILD=false
IMAGES_ONLY=false
HTML_ONLY=false
DRY_RUN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --force)
            FORCE_FULL_DEPLOY=true
            shift
            ;;
        --skip-build)
            SKIP_BUILD=true
            shift
            ;;
        --images-only)
            IMAGES_ONLY=true
            shift
            ;;
        --html-only)
            HTML_ONLY=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help)
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --force        Force full deployment (ignore manifest cache)"
            echo "  --skip-build   Skip Jekyll build (use existing _site)"
            echo "  --images-only  Only sync images directory"
            echo "  --html-only    Only sync HTML/CSS/JS (skip images)"
            echo "  --dry-run      Show what would be uploaded without uploading"
            echo "  --help         Show this help message"
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            exit 1
            ;;
    esac
done

echo -e "${CYAN}======================================${NC}"
echo -e "${CYAN}  Games Y'all Production Deployment${NC}"
echo -e "${CYAN}======================================${NC}"
echo -e "${YELLOW}Project root: $PROJECT_ROOT${NC}"

# Detect platform
if [[ "$OSTYPE" == "darwin"* ]]; then
    PLATFORM="macos"
    MD5_CMD="md5 -r"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    PLATFORM="linux"
    MD5_CMD="md5sum"
else
    PLATFORM="unknown"
    MD5_CMD="md5sum"
fi

echo -e "${YELLOW}Detected platform: $PLATFORM${NC}"

# Install required packages based on platform
if [ "$PLATFORM" = "macos" ]; then
    if ! command -v brew &> /dev/null; then
        echo -e "${RED}Homebrew not found. Please install it first: https://brew.sh${NC}"
        exit 1
    fi

    if ! command -v lftp &> /dev/null; then
        echo -e "${YELLOW}Installing lftp via Homebrew...${NC}"
        brew install lftp
    fi
elif [ "$PLATFORM" = "linux" ]; then
    if ! command -v lftp &> /dev/null; then
        echo -e "${YELLOW}Installing lftp...${NC}"
        sudo apt-get update && sudo apt-get install -y lftp
    fi
fi

# Create manifest directory if it doesn't exist
mkdir -p "$MANIFEST_DIR"

# Function to generate hash manifest of built files
generate_hash_manifest() {
    local site_dir="$1"
    local manifest_file="$2"
    local filter_pattern="${3:-}"  # Optional: "images" or "html"

    echo -e "${YELLOW}Generating content hash manifest...${NC}"

    # Create temp file for manifest
    local temp_manifest=$(mktemp)

    if [ "$filter_pattern" = "images" ]; then
        # Only hash image files
        find "$site_dir" -type f \( -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.webp" -o -name "*.svg" -o -name "*.ico" \) \
            ! -name ".DS_Store" | while read -r file; do
            rel_path="${file#$site_dir/}"
            hash=$($MD5_CMD "$file" | awk '{print $1}')
            echo "$hash  $rel_path"
        done | sort -k2 > "$temp_manifest"
    elif [ "$filter_pattern" = "html" ]; then
        # Only hash non-image files
        find "$site_dir" -type f \( -name "*.html" -o -name "*.css" -o -name "*.js" -o -name "*.xml" -o -name "*.json" -o -name "*.txt" -o -name "*.woff" -o -name "*.woff2" -o -name "*.ttf" -o -name "*.eot" \) \
            ! -name ".DS_Store" | while read -r file; do
            rel_path="${file#$site_dir/}"
            hash=$($MD5_CMD "$file" | awk '{print $1}')
            echo "$hash  $rel_path"
        done | sort -k2 > "$temp_manifest"
    else
        # Hash all files
        find "$site_dir" -type f ! -name ".DS_Store" ! -name ".git*" | while read -r file; do
            rel_path="${file#$site_dir/}"
            hash=$($MD5_CMD "$file" | awk '{print $1}')
            echo "$hash  $rel_path"
        done | sort -k2 > "$temp_manifest"
    fi

    mv "$temp_manifest" "$manifest_file"
    local file_count=$(wc -l < "$manifest_file" | tr -d ' ')
    echo -e "${YELLOW}Hash manifest created with ${file_count} files${NC}"
}

# Function to compare manifests and create file lists
compare_manifests() {
    local local_manifest="$1"
    local remote_manifest="$2"
    local upload_list="$3"
    local delete_list="$4"

    echo -e "${YELLOW}Comparing local and remote manifests...${NC}"

    # If no remote manifest exists, upload everything
    if [ ! -f "$remote_manifest" ] || [ ! -s "$remote_manifest" ]; then
        echo -e "${YELLOW}No previous manifest found - will upload all files${NC}"
        cut -d' ' -f3- "$local_manifest" > "$upload_list"
        touch "$delete_list"
        return 0
    fi

    # Create temp files for comparison
    local local_sorted=$(mktemp)
    local remote_sorted=$(mktemp)

    sort "$local_manifest" > "$local_sorted"
    sort "$remote_manifest" > "$remote_sorted"

    # Find files that are new or changed (in local but not in remote with same hash)
    # Format: "hash  filename" - we compare the whole line
    comm -23 "$local_sorted" "$remote_sorted" | cut -d' ' -f3- > "$upload_list"

    # Find files to delete (in remote but filename not in local)
    local local_files=$(mktemp)
    local remote_files=$(mktemp)
    cut -d' ' -f3- "$local_manifest" | sort > "$local_files"
    cut -d' ' -f3- "$remote_manifest" | sort > "$remote_files"
    comm -13 "$local_files" "$remote_files" > "$delete_list"

    # Cleanup temp files
    rm -f "$local_sorted" "$remote_sorted" "$local_files" "$remote_files"

    local upload_count=$(wc -l < "$upload_list" | tr -d ' ')
    local delete_count=$(wc -l < "$delete_list" | tr -d ' ')

    echo -e "${GREEN}Files to upload: $upload_count${NC}"
    echo -e "${GREEN}Files to delete: $delete_count${NC}"

    if [ "$upload_count" -eq 0 ] && [ "$delete_count" -eq 0 ]; then
        return 1  # No changes
    fi

    return 0
}

# Function to upload files from a list using lftp
upload_files_from_list() {
    local site_dir="$1"
    local file_list="$2"
    local remote_path="$3"

    local file_count=$(wc -l < "$file_list" | tr -d ' ')

    if [ "$file_count" -eq 0 ]; then
        echo -e "${GREEN}No files to upload${NC}"
        return 0
    fi

    echo -e "${YELLOW}Uploading $file_count changed files...${NC}"

    if [ "$DRY_RUN" = true ]; then
        echo -e "${CYAN}DRY RUN - Files that would be uploaded:${NC}"
        head -50 "$file_list"
        if [ "$file_count" -gt 50 ]; then
            echo -e "${CYAN}... and $((file_count - 50)) more files${NC}"
        fi
        return 0
    fi

    # Create lftp script for batch upload
    local lftp_script=$(mktemp)

    cat > "$lftp_script" << 'LFTP_EOF'
set sftp:auto-confirm yes
set ssl:verify-certificate no
set ftp:ssl-allow no
set net:max-retries 3
set net:reconnect-interval-base 5
set net:reconnect-interval-multiplier 2
set net:reconnect-interval-max 60
set cmd:parallel 1
set net:timeout 60
set sftp:connect-program "ssh -o ConnectTimeout=30 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o TCPKeepAlive=yes"
LFTP_EOF

    printf "open sftp://%s\n" "$PRODUCTION_HOST" >> "$lftp_script"
    printf "user %s \"%s\"\n" "$PRODUCTION_USERNAME" "$PRODUCTION_PASSWORD" >> "$lftp_script"
    printf "lcd %s\n" "$site_dir" >> "$lftp_script"
    printf "cd %s\n" "$remote_path" >> "$lftp_script"

    # Add each file to upload with directory creation
    local current_dir=""
    while IFS= read -r file; do
        [ -z "$file" ] && continue

        local dir=$(dirname "$file")
        if [ "$dir" != "." ] && [ "$dir" != "$current_dir" ]; then
            printf "mkdir -p %s\n" "$dir" >> "$lftp_script"
            current_dir="$dir"
        fi
        printf "put -O %s %s\n" "$(dirname "$file")" "$file" >> "$lftp_script"
    done < "$file_list"

    echo "bye" >> "$lftp_script"

    # Execute lftp
    lftp -f "$lftp_script"
    local result=$?

    rm -f "$lftp_script"
    return $result
}

# Function to delete files from a list using lftp
delete_files_from_list() {
    local file_list="$1"
    local remote_path="$2"

    local file_count=$(wc -l < "$file_list" | tr -d ' ')

    if [ "$file_count" -eq 0 ]; then
        return 0
    fi

    echo -e "${YELLOW}Deleting $file_count removed files from server...${NC}"

    if [ "$DRY_RUN" = true ]; then
        echo -e "${CYAN}DRY RUN - Files that would be deleted:${NC}"
        cat "$file_list"
        return 0
    fi

    local lftp_script=$(mktemp)

    cat > "$lftp_script" << 'LFTP_EOF'
set sftp:auto-confirm yes
set ssl:verify-certificate no
set net:max-retries 2
set net:timeout 60
set sftp:connect-program "ssh -o ConnectTimeout=30 -o ServerAliveInterval=60"
LFTP_EOF

    printf "open sftp://%s\n" "$PRODUCTION_HOST" >> "$lftp_script"
    printf "user %s \"%s\"\n" "$PRODUCTION_USERNAME" "$PRODUCTION_PASSWORD" >> "$lftp_script"
    printf "cd %s\n" "$remote_path" >> "$lftp_script"

    while IFS= read -r file; do
        [ -z "$file" ] && continue
        printf "rm -f %s\n" "$file" >> "$lftp_script"
    done < "$file_list"

    echo "bye" >> "$lftp_script"

    lftp -f "$lftp_script"
    local result=$?

    rm -f "$lftp_script"
    return $result
}

# Validate environment variables
if [ -z "$PRODUCTION_HOST" ] || [ -z "$PRODUCTION_USERNAME" ] || [ -z "$PRODUCTION_PASSWORD" ]; then
    echo -e "${RED}ERROR: Missing required environment variables in .env file${NC}"
    echo -e "${RED}Required: PRODUCTION_HOST, PRODUCTION_USERNAME, PRODUCTION_PASSWORD${NC}"
    exit 1
fi

# Determine the site directory
if [ "$SKIP_BUILD" = true ]; then
    # Use existing _site directory
    SITE_DIR="$PROJECT_ROOT/games_yall_site/_site"
    if [ ! -d "$SITE_DIR" ]; then
        echo -e "${RED}ERROR: _site directory not found. Run without --skip-build first.${NC}"
        exit 1
    fi
    echo -e "${YELLOW}Using existing _site directory (skipping build)${NC}"
else
    # Create a temporary directory for the build
    TEMP_DIR=$(mktemp -d)
    echo -e "${YELLOW}Created temporary directory: $TEMP_DIR${NC}"

    # Cleanup function
    cleanup() {
        if [ -n "$TEMP_DIR" ] && [ -d "$TEMP_DIR" ]; then
            echo -e "${YELLOW}Cleaning up temporary directory...${NC}"
            rm -rf "$TEMP_DIR"
        fi
    }
    trap cleanup EXIT

    # Copy files to temp directory
    echo -e "${YELLOW}Copying files to temp directory...${NC}"
    cp -R "$PROJECT_ROOT"/* "$TEMP_DIR"
    cp -R "$PROJECT_ROOT"/.[^.]* "$TEMP_DIR" 2>/dev/null || :

    # Change to the Jekyll site directory
    cd "$TEMP_DIR/games_yall_site"

    # Check if Gemfile exists
    if [ ! -f "Gemfile" ]; then
        echo -e "${RED}ERROR: Gemfile not found in $TEMP_DIR/games_yall_site${NC}"
        exit 1
    fi

    # Install Ruby dependencies and build the Jekyll site
    echo -e "${YELLOW}Installing Jekyll dependencies...${NC}"
    bundle install --quiet

    echo -e "${YELLOW}Building Jekyll site...${NC}"
    JEKYLL_ENV=production bundle exec jekyll build

    # Check if the build was successful
    if [ ! -d "_site" ]; then
        echo -e "${RED}ERROR: Jekyll build failed - _site directory not found${NC}"
        exit 1
    fi

    SITE_DIR="$TEMP_DIR/games_yall_site/_site"
fi

echo -e "${CYAN}======================================${NC}"
echo -e "${CYAN}  Analyzing Changes${NC}"
echo -e "${CYAN}======================================${NC}"

# Clear force flag resets the manifest
if [ "$FORCE_FULL_DEPLOY" = true ]; then
    echo -e "${YELLOW}Force deploy requested - clearing cached manifest${NC}"
    rm -f "$REMOTE_MANIFEST"
fi

# Determine what to sync based on flags
FILTER_MODE=""
if [ "$IMAGES_ONLY" = true ]; then
    FILTER_MODE="images"
    echo -e "${YELLOW}Mode: Images only${NC}"
elif [ "$HTML_ONLY" = true ]; then
    FILTER_MODE="html"
    echo -e "${YELLOW}Mode: HTML/CSS/JS only (skipping images)${NC}"
else
    echo -e "${YELLOW}Mode: Full site${NC}"
fi

# Generate local manifest
generate_hash_manifest "$SITE_DIR" "$LOCAL_MANIFEST" "$FILTER_MODE"

# Compare with remote manifest
if compare_manifests "$LOCAL_MANIFEST" "$REMOTE_MANIFEST" "$UPLOAD_LIST" "$DELETE_LIST"; then
    echo -e "${CYAN}======================================${NC}"
    echo -e "${CYAN}  Deploying Changes${NC}"
    echo -e "${CYAN}======================================${NC}"

    echo -e "${YELLOW}Host: $PRODUCTION_HOST${NC}"
    echo -e "${YELLOW}Path: ${PRODUCTION_PATH:-/}${NC}"

    # Show summary of changes
    if [ -s "$UPLOAD_LIST" ]; then
        echo -e "${YELLOW}Sample of files to upload:${NC}"
        head -10 "$UPLOAD_LIST" | sed 's/^/  /'
        upload_count=$(wc -l < "$UPLOAD_LIST" | tr -d ' ')
        if [ "$upload_count" -gt 10 ]; then
            echo -e "  ${CYAN}... and $((upload_count - 10)) more files${NC}"
        fi
    fi

    # Upload changed files
    if ! upload_files_from_list "$SITE_DIR" "$UPLOAD_LIST" "${PRODUCTION_PATH:-/}"; then
        echo -e "${RED}Upload failed!${NC}"
        exit 1
    fi

    # Delete removed files
    if [ -s "$DELETE_LIST" ]; then
        if ! delete_files_from_list "$DELETE_LIST" "${PRODUCTION_PATH:-/}"; then
            echo -e "${YELLOW}Warning: Some file deletions may have failed${NC}"
        fi
    fi

    # Update remote manifest with current state (only if not dry run)
    if [ "$DRY_RUN" != true ]; then
        cp "$LOCAL_MANIFEST" "$REMOTE_MANIFEST"
        echo -e "${GREEN}Manifest cache updated${NC}"
    fi

    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}  Deployment Complete!${NC}"
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}Visit https://gamesyall.com to review the changes.${NC}"
else
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}  No Changes Detected${NC}"
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}Site is already up to date. Nothing to deploy.${NC}"
fi
